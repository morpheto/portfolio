<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Orhun Ege Eker — Space Portfolio</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#05060a; --text:#f6f7fb; --muted:#cbd5e1; --accent:#1e5eff; }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
  canvas#scene{position:fixed;inset:0;width:100%;height:100%;display:block}

  /* HUD */
  .hud{position:fixed;top:12px;left:12px;right:12px;z-index:20;display:flex;justify-content:space-between;align-items:center;padding:10px 14px;background:rgba(8,10,18,.45);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(8px);border-radius:16px}
  .brand{font-weight:800;letter-spacing:.4px;font-size:16px}
  .nav{display:flex;gap:16px}
  .nav a{color:var(--text);text-decoration:none;opacity:.9;font-size:14px}

  .help{position:fixed;right:12px;bottom:12px;z-index:20;color:var(--muted);font-size:12px;padding:10px 12px;border:1px solid rgba(255,255,255,.12);border-radius:12px;background:rgba(255,255,255,.06);backdrop-filter:blur(6px)}

  /* Overlay cards */
  .overlay{position:fixed;inset:0;pointer-events:none;z-index:12}
  .planet-card{position:absolute;transform:translate(-50%,-100%);width:240px;max-width:40vw;border-radius:12px;overflow:hidden;border:1px solid rgba(120,198,255,.28);background:linear-gradient(180deg, rgba(20,24,40,.85), rgba(10,12,20,.9));box-shadow:0 10px 26px rgba(0,0,0,.45);transition:opacity .15s ease, transform .15s ease;opacity:.0; pointer-events:auto}
  .planet-card__media{position:relative;height:120px;background:#0f1430;background-size:cover;background-position:center}
  .planet-card__meta{display:flex;justify-content:space-between;align-items:center;padding:8px 10px}
  .title{font-weight:700}
  .badge{position:absolute;left:8px;top:8px;background:rgba(64,191,255,.12);border:1px solid rgba(64,191,255,.4);backdrop-filter:blur(6px);font-size:11px;padding:6px 8px;border-radius:999px;color:#cfefff}
  .enter-pill{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);padding:6px 10px;border-radius:999px;border:1px solid rgba(120,198,255,.35);background:rgba(64,191,255,.10);color:#dff2ff;font-size:12px;box-shadow:0 0 16px rgba(64,191,255,.25);opacity:0;transition:opacity .15s ease;pointer-events:none}

  /* Quick View */
  .popup{position:fixed;inset:0;z-index:60;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(4px)}
  .popup.show{display:flex}
  .popup-card{width:min(820px,92vw);border:1px solid rgba(120,198,255,.28);border-radius:16px;background:#0b0f1c;box-shadow:0 20px 60px rgba(0,0,0,.55);overflow:hidden}
  .popup-media{height:min(52vh,460px);background:#0e1433;background-size:cover;background-position:center}
  .popup-body{padding:12px 14px;display:flex;align-items:center;justify-content:space-between;gap:10px}
  .popup-title{font-weight:800;font-size:18px}.popup-tag{font-size:12px;color:#cfd6e3}
  .popup-actions{display:flex;gap:10px}
  .btn{padding:10px 14px;border-radius:10px;border:1px solid rgba(120,198,255,.3);background:#10172b;color:#fff;font-size:14px;cursor:pointer}
  .btn.primary{background:var(--accent);border-color:#2b66ff}

  /* Start */
  .start{position:fixed;inset:0;z-index:50;display:flex;align-items:center;justify-content:center;background:radial-gradient(1200px 600px at 50% -20%, rgba(120,170,255,.08), rgba(5,6,10,.95))}
  .start.hide{animation:fade .6s both}@keyframes fade{to{opacity:0;visibility:hidden}}
  .start-card{padding:22px 24px;border:1px solid rgba(255,255,255,.12);background:rgba(10,12,20,.72);backdrop-filter:blur(8px);border-radius:16px;display:flex;flex-direction:column;gap:10px;align-items:center;min-width:260px}
  .start-card h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px;text-align:center}
  .start-sub{margin:0 0 8px;font-size:12px;color:#d0d7e4;opacity:.92;text-align:center}
  .kbd{font-weight:700;border:1px solid rgba(255,255,255,.18);padding:2px 6px;border-radius:6px;background:rgba(255,255,255,.06)}
  .actions{display:flex;gap:10px;margin-top:4px;flex-wrap:wrap;justify-content:center}
  .btn.linklike{background:transparent}

  /* Mobile gate */
  .mobile-gate{position:fixed;inset:0;z-index:70;display:none;align-items:center;justify-content:center;background:radial-gradient(800px 400px at 50% 50%, rgba(120,170,255,.12), rgba(5,6,10,.95));backdrop-filter:blur(6px)}
  .mobile-card{padding:24px 28px;border:1px solid rgba(255,255,255,.18);background:linear-gradient(180deg, rgba(20,24,40,.9), rgba(10,12,20,.95));border-radius:20px;max-width:360px;text-align:center;box-shadow:0 8px 24px rgba(0,0,0,.4)}
  .mobile-card h2{margin:0 0 10px;font-size:20px;font-weight:700;color:#e0e7ff}
  .mobile-card p{margin:0 0 16px;font-size:15px;color:#d0d7e4;line-height:1.5}
  .mobile-card .btn.primary{padding:12px 20px;font-size:15px;border-radius:12px}

  /* Glow cursor */
  .cursor-dot{position:fixed;left:0;top:0;width:14px;height:14px;border-radius:999px;pointer-events:none;transform:translate(-50%,-50%);background:rgba(120,200,255,.25);box-shadow:0 0 22px rgba(120,200,255,.85), 0 0 44px rgba(120,200,255,.4);z-index:80}
</style>
</head>
<body>
  <div class="hud">
    <div class="brand">ORHUN EGE EKER</div>
    <div class="nav">
      <a href="index.html">SPACE</a>
      <a href="projects.html">PROJECTS</a>
      <a href="about.html">ABOUT</a>
      <a href="contact.html">CONTACT</a>
    </div>
  </div>

  <div class="help" id="helpBox">Loading controls…</div>
  <div class="overlay" id="overlay"></div>

  <!-- Quick View -->
  <div class="popup" id="quickview" aria-hidden="true">
    <div class="popup-card" role="dialog" aria-modal="true">
      <div class="popup-media" id="qvMedia"></div>
      <div class="popup-body">
        <div>
          <div class="popup-title" id="qvTitle">Project</div>
          <div class="popup-tag" id="qvTag">Category</div>
        </div>
        <div class="popup-actions">
          <a class="btn primary" id="qvEnter" href="projects.html">View in Portfolio (E)</a>
          <button class="btn" id="qvExit" type="button">Quit (Q)</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Start -->
  <div class="start" id="start">
    <div class="start-card">
      <h1>Orhun Ege Eker — Space Tour</h1>
      <div class="start-sub">Explore projects in a tiny galaxy</div>
      <div class="actions">
        <a class="btn linklike" href="projects.html">Basic Portfolio</a>
        <button id="btnStart" class="btn primary" type="button">Start</button>
      </div>
      <p style="margin:8px 0 0;font-size:12px;opacity:.85">
        <span class="kbd">W/S</span> move · mouse turn · near planet <span class="kbd">E</span> enter
      </p>
    </div>
  </div>

  <!-- Mobile gate -->
  <div class="mobile-gate" id="mobileGate">
    <div class="mobile-card">
      <h2>Hey there!</h2>
      <p>This space adventure is best enjoyed on a computer for now. Want to check out my projects? Hop over to the basic portfolio instead!</p>
      <a class="btn primary" href="projects.html">Explore Basic Portfolio</a>
    </div>
  </div>

  <canvas id="scene"></canvas>
  <div class="cursor-dot" id="cursorDot" aria-hidden="true"></div>

  <!-- Import map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <!-- App -->
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { clone as cloneSkeleton } from 'three/addons/utils/SkeletonUtils.js';

    const TAU = Math.PI * 2;
    const angleDelta = (from, to) => { let d = (to - from) % TAU; if (d > Math.PI) d -= TAU; if (d < -Math.PI) d += TAU; return d; };
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const rand=(a,b)=>a+Math.random()*(b-a);
    const isTouch = matchMedia('(pointer:coarse)').matches || ('ontouchstart' in window);

    /* Mobile gate */
    const mobileGate = document.getElementById('mobileGate');
    if (isTouch) mobileGate.style.display = 'flex';

    /* HUD help */
    const helpBox=document.getElementById('helpBox');
    helpBox.innerHTML = isTouch
      ? '<b>Mobile</b> — This space tour shines on desktop! Try the Basic Portfolio for now.'
      : '<b>Desktop</b> — Mouse move: turn · <b>W/S</b> forward/back · <b>A/D</b> turn · Near planet: <b>E</b> enter · In modal: <b>Q</b> exit';

    /* Cursor glow */
    (function(){ const dot=document.getElementById('cursorDot'); let x=0,y=0,raf=null;
      addEventListener('mousemove',e=>{x=e.clientX;y=e.clientY;if(!raf){raf=requestAnimationFrame(()=>{dot.style.left=x+'px';dot.style.top=y+'px';raf=null;});}}, {passive:true});
      addEventListener('mouseleave',()=>{dot.style.opacity=.2}); addEventListener('mouseenter',()=>{dot.style.opacity=1});
    })();

    /* Particle textures */
    function makeRadialTexture(inner, outer, size=128){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const ctx=c.getContext('2d'); const g=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
      g.addColorStop(0,inner); g.addColorStop(1,outer); ctx.fillStyle=g; ctx.fillRect(0,0,size,size);
      const t=new THREE.CanvasTexture(c); t.minFilter=THREE.LinearFilter; t.magFilter=THREE.LinearFilter; return t;
    }
    const flameTex = makeRadialTexture('rgba(120,230,255,1)','rgba(0,170,255,0)');
    const smokeTex = makeRadialTexture('rgba(160,210,255,0.55)','rgba(90,140,200,0)');

    /* Scene */
    const renderer = new THREE.WebGLRenderer({canvas:document.getElementById('scene'), antialias:true});
    renderer.setPixelRatio(Math.min(2, devicePixelRatio||1)); renderer.setSize(innerWidth, innerHeight);
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x05060a);
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 6000);

    scene.add(new THREE.HemisphereLight(0x89b4ff, 0x05060a, .55));
    const sun = new THREE.DirectionalLight(0xffffff,.85); sun.position.set(160,220,120); scene.add(sun);

    /* Stars */
    (function(){
      const g=new THREE.BufferGeometry(), N=2500, pos=new Float32Array(N*3);
      for(let i=0;i<N;i++){const R=900+Math.random()*1400, th=Math.random()*Math.PI*2, u=Math.random()*2-1, s=Math.sqrt(1-u*u);
        pos[i*3]=R*s*Math.cos(th); pos[i*3+1]=R*u*0.7; pos[i*3+2]=R*s*Math.sin(th);} 
      g.setAttribute('position', new THREE.BufferAttribute(pos,3));
      scene.add(new THREE.Points(g,new THREE.PointsMaterial({size:1.6,color:0xbfd9ff,sizeAttenuation:true})));
    })();

    /* Galaxies */
    (function(){
      const galaxies = [];
      function galaxyTexture(){
        const s=256, c=document.createElement('canvas'); c.width=c.height=s; const ctx=c.getContext('2d');
        const g=ctx.createRadialGradient(s/2,s/2,4,s/2,s/2,s/2);
        g.addColorStop(0,'rgba(255,255,255,.9)');
        g.addColorStop(.3,'rgba(180,210,255,.55)');
        g.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=g; ctx.fillRect(0,0,s,s);
        return new THREE.CanvasTexture(c);
      }
      const tex = galaxyTexture();
      for(let i=0;i<6;i++){
        const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false,opacity:.9}));
        const R=800+Math.random()*800, a=Math.random()*Math.PI*2, h=THREE.MathUtils.randFloatSpread(200);
        sp.position.set(Math.cos(a)*R,h,Math.sin(a)*R); sp.scale.setScalar(120+Math.random()*120);
        sp.material.opacity = .35 + Math.random()*.25;
        scene.add(sp); galaxies.push(sp);
      }
    })();

    /* Black hole */
    (function(){
      const disk = new THREE.Mesh(
        new THREE.TorusGeometry(28, 5.2, 2, 100),
        new THREE.MeshStandardMaterial({color:0x6aa7ff, emissive:0x1534a6, emissiveIntensity:.8, metalness:.2, roughness:.4, side:THREE.DoubleSide, transparent:true, opacity:.5})
      );
      disk.rotation.x = Math.PI/2;
      disk.position.set(-260, -40, -120);
      scene.add(disk);
      const s=256, c=document.createElement('canvas'); c.width=c.height=s; const ctx=c.getContext('2d');
      const g=ctx.createRadialGradient(s/2,s/2,0,s/2,s/2,s/2);
      g.addColorStop(0,'rgba(0,0,0,1)'); g.addColorStop(.6,'rgba(0,0,0,.8)'); g.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(s/2,s/2,s/2,0,Math.PI*2); ctx.fill();
      const bhTex=new THREE.CanvasTexture(c);
      const core=new THREE.Sprite(new THREE.SpriteMaterial({map:bhTex,transparent:true,depthWrite:false,opacity:.9}));
      core.position.copy(disk.position); core.scale.setScalar(80); scene.add(core);
      const spin = ()=>{ disk.rotation.z += 0.0016; requestAnimationFrame(spin); }; spin();
    })();

    /* Planet textures (variety back) */
    function createMoonTexture(){
      const size=1024, c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      ctx.fillStyle='#777'; ctx.fillRect(0,0,size,size);
      for(let i=0;i<220;i++){const x=Math.random()*size,y=Math.random()*size,r=8+Math.random()*36;
        const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,'#555'); g.addColorStop(.6,'#666'); g.addColorStop(1,'rgba(100,100,100,.4)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();}
      return new THREE.CanvasTexture(c);
    }
    function createMoonHeight(){
      const size=1024, c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      ctx.fillStyle='#000'; ctx.fillRect(0,0,size,size);
      for(let i=0;i<220;i++){const x=Math.random()*size,y=Math.random()*size,r=8+Math.random()*36;
        const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,'#fff'); g.addColorStop(.6,'#aaa'); g.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();}
      return new THREE.CanvasTexture(c);
    }
    function createRockyTexture(){
      const size=1024, c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      ctx.fillStyle='#8b4513'; ctx.fillRect(0,0,size,size);
      for(let i=0;i<160;i++){const x=Math.random()*size,y=Math.random()*size,r=12+Math.random()*30;
        const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,'#a0522d'); g.addColorStop(1,'rgba(139,69,19,.3)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();}
      for(let i=0;i<60;i++){const x=Math.random()*size,y=Math.random()*size,r=18+Math.random()*50;
        const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,'#cd853f'); g.addColorStop(1,'rgba(205,133,63,.2)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();}
      return new THREE.CanvasTexture(c);
    }
    function createRockyHeight(){
      const size=1024, c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      ctx.fillStyle='#000'; ctx.fillRect(0,0,size,size);
      for(let i=0;i<200;i++){const x=Math.random()*size,y=Math.random()*size,r=10+Math.random()*36;
        const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,'#fff'); g.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();}
      return new THREE.CanvasTexture(c);
    }
    function createGasTexture(){
      const size=1024, c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      const g=ctx.createLinearGradient(0,0,0,size);
      g.addColorStop(0,'#4682b4'); g.addColorStop(.3,'#87ceeb'); g.addColorStop(.7,'#4682b4'); g.addColorStop(1,'#20b2aa');
      ctx.fillStyle=g; ctx.fillRect(0,0,size,size);
      for(let i=0;i<80;i++){const x=Math.random()*size,y=Math.random()*size,r=30+Math.random()*60;
        ctx.fillStyle='rgba(255,255,255,0.12)'; ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();}
      return new THREE.CanvasTexture(c);
    }

    const moonTex=createMoonTexture(), moonDisp=createMoonHeight();
    const rockyTex=createRockyTexture(), rockyDisp=createRockyHeight();
    const gasTex=createGasTexture(); // smooth, no disp

    /* Projects / planets */
    const PROJECTS=[
      {id:'p1',title:'Audio Reactive + Hand Tracked Visualizer',tag:'TouchDesigner',cover:'media/covers/p1.jpg',type:'moon'},
      {id:'p2',title:'Odin Pendant Animation',tag:'3D Works',cover:'media/covers/p2.jpg',type:'rocky'},
      {id:'p3',title:'MediaPipe + Ableton + PointCloud',tag:'Interactive',cover:'media/covers/p3.jpg',type:'gas'},
      {id:'p4',title:'Nike Air Jordan CGI',tag:'CGI',cover:'media/covers/p4.jpg',type:'rocky'},
      {id:'p5',title:'Bic Mini Lighter Spider Case',tag:'Product CGI',cover:'media/covers/p5.jpg',type:'moon'},
      {id:'p6',title:'Space Keycap Animation',tag:'3D Works',cover:'media/covers/p6.jpg',type:'gas'},
      {id:'p7',title:'Oxidized Silver Jewelry — Maverick',tag:'LookDev',cover:'media/covers/p7.jpg',type:'rocky'},
      {id:'p8',title:'YouTube Channel Intro',tag:'Motion · Audio',cover:'media/covers/p8.jpg',type:'moon'},
      {id:'p9',title:'AI Visualizer from Image',tag:'AI Visuals',cover:'media/covers/p9.jpg',type:'gas'}
    ];
    function appearanceFor(p){
      if(p.type==='moon')  return {h:0.0,s:0.1,l:0.42,metal:0.2,rough:0.85,ring:false,emiss:0.08,texture:moonTex,disp:moonDisp};
      if(p.type==='rocky') return {h:0.08,s:0.5,l:0.32,metal:0.28,rough:0.75,ring:Math.random()<0.28,emiss:0.1,texture:rockyTex,disp:rockyDisp};
      if(p.type==='gas')   return {h:0.58,s:0.6,l:0.5,metal:0.1,rough:0.95,ring:Math.random()<0.42,emiss:0.22,texture:gasTex,disp:null};
      return {h:0.66,s:0.40,l:0.58,metal:0.22,rough:0.55,ring:Math.random()<0.5,emiss:0.18,texture:null,disp:null};
    }

    const overlay=document.getElementById('overlay');
    const planets=[], cardsRef=[], tmpV=new THREE.Vector3();
    const sphereGeo=new THREE.SphereGeometry(1,64,48);
    function makePlanet(r,app){
      const col=new THREE.Color().setHSL(app.h,app.s,app.l);
      const mat=new THREE.MeshStandardMaterial({
        color:col.getHex(), roughness:app.rough, metalness:app.metal,
        emissive:col.clone().multiplyScalar(app.emiss).getHex(), emissiveIntensity:1,
        map:app.texture
      });
      if(app.disp){
        mat.displacementMap = app.disp;
        mat.displacementScale = 0.18;
        mat.normalMap = app.disp;
        mat.normalScale = new THREE.Vector2(0.7,0.7);
      }
      const m=new THREE.Mesh(sphereGeo,mat);
      m.rotation.z = THREE.MathUtils.degToRad(THREE.MathUtils.randFloatSpread(12));
      if(app.ring){
        const ring=new THREE.Mesh(
          new THREE.RingGeometry(r*1.01,r*1.045,72),
          new THREE.MeshBasicMaterial({color:col.clone().offsetHSL(.08,0,0).getHex(),transparent:true,opacity:.12,side:THREE.DoubleSide})
        );
        ring.rotation.x=-Math.PI/2 + THREE.MathUtils.randFloatSpread(.28);
        ring.rotation.z=Math.random()*Math.PI*2; m.add(ring);
      }
      m.scale.setScalar(r); m.userData.spin=THREE.MathUtils.randFloat(0.02,0.05);
      m.userData.radius = r;
      return m;
    }
    const POS=[], RMIN=70, RMAX=150;
    for(let i=0;i<PROJECTS.length;i++){const R=THREE.MathUtils.randFloat(RMIN,RMAX), th=(i/PROJECTS.length)*Math.PI*2+Math.random()*0.6;
      POS.push([Math.cos(th)*R+THREE.MathUtils.randFloatSpread(20), THREE.MathUtils.randFloatSpread(18), Math.sin(th)*R+THREE.MathUtils.randFloatSpread(20)]);} 
    for(let i=POS.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [POS[i],POS[j]]=[POS[j],POS[i]];}
    PROJECTS.forEach((p,i)=>{
      const r=THREE.MathUtils.randFloat(9,16), app=appearanceFor(p), m=makePlanet(r,app); const [x,y,z]=POS[i];
      m.position.set(x,y,z); m.userData.project=p; scene.add(m); planets.push(m);
      const el=document.createElement('div'); el.className='planet-card';
      const cover=p.cover?`background-image:url('${p.cover}')`:`background-image:none`;
      el.innerHTML=`<div class="planet-card__media" style="${cover}">
        <div class="badge">${p.tag||''}</div>
        <div class="enter-pill">Press <b>E</b> to Enter</div>
      </div>
      <div class="planet-card__meta"><div class="title">${p.title}</div></div>`;
      overlay.appendChild(el);
      const pill=el.querySelector('.enter-pill');
      const item={el,obj:m,pill}; el.addEventListener('click',()=>{ if(nearest===m) qvOpenFor(m); }); cardsRef.push(item);
    });

    /* Player ship */
    const ship=new THREE.Group(); scene.add(ship);
    const hull=new THREE.Mesh(new THREE.CapsuleGeometry(.8,3,6,12),
      new THREE.MeshStandardMaterial({color:0x9aa7ff,roughness:.55,metalness:.2,emissive:0x10163a,emissiveIntensity:.2}));
    hull.rotation.z=Math.PI/2; ship.add(hull);

    const loader = new GLTFLoader();
    let exhaustLocal=new THREE.Vector3(-2,0,0);
    let baseModel=null;

    function fitModelToShip(model){
      const box0 = new THREE.Box3().setFromObject(model);
      const size0 = new THREE.Vector3(); box0.getSize(size0);
      const s = 6 / Math.max(size0.x,size0.y,size0.z || 1);
      model.scale.setScalar(s);
      model.rotation.set(0, Math.PI/2, 0);
      const b1 = new THREE.Box3().setFromObject(model);
      const c1 = new THREE.Vector3(); b1.getCenter(c1);
      model.position.sub(c1);
      const b2 = new THREE.Box3().setFromObject(model);
      return { exhaustLocal: new THREE.Vector3(b2.min.x - 0.6, 0, 0) };
    }

    loader.load('media/spaceship.glb', (gltf)=>{
      baseModel = gltf.scene || gltf.scenes?.[0];
      if(baseModel){
        ship.clear();
        const m = cloneSkeleton(baseModel);
        const info = fitModelToShip(m);
        exhaustLocal.copy(info.exhaustLocal);
        ship.add(m);
      }
      spawnAIShips();
    });

    /* Particles pools */
    function makeSprite(mat){const s=new THREE.Sprite(mat.clone()); s.visible=false; scene.add(s); return s;}
    const flameMat=new THREE.SpriteMaterial({map:flameTex,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,opacity:.95});
    const smokeMat=new THREE.SpriteMaterial({map:smokeTex,transparent:true,depthWrite:false,opacity:.0});
    function makeParticlePools(flames=80, smokes=40){
      const fPool=[...Array(flames)].map(()=>makeSprite(flameMat));
      const sPool=[...Array(smokes)].map(()=>makeSprite(smokeMat));
      const fData=fPool.map(()=>({life:0,max:0,vel:new THREE.Vector3()}));
      const sData=sPool.map(()=>({life:0,max:0,vel:new THREE.Vector3()}));
      return {fPool,sPool,fData,sData};
    }
    const playerPools = makeParticlePools(140,100);
    function worldFromExhaust(group, exhaust, out){return out.copy(exhaust).applyQuaternion(group.quaternion).add(group.position);}
    function spawnFlameAt(group, exhaust, pools, n,intensity=1){
      const {fPool,fData}=pools;
      for(let i=0;i<fPool.length&&n>0;i++){
        if(fData[i].life>0)continue; n--;
        const sp=fPool[i],d=fData[i]; const pos=new THREE.Vector3(); worldFromExhaust(group,exhaust,pos);
        sp.position.copy(pos); sp.scale.setScalar(1.0+Math.random()*1.6*intensity);
        d.max=.38+Math.random()*.28; d.life=d.max;
        const dir=new THREE.Vector3(-1,THREE.MathUtils.randFloatSpread(.35),THREE.MathUtils.randFloatSpread(.35)).applyQuaternion(group.quaternion);
        d.vel.copy(dir.multiplyScalar(13+20*intensity)); sp.material.opacity=.95; sp.visible=true;
      }
    }
    function spawnSmokeAt(group, exhaust, pools, n,boost=1){
      const {sPool,sData}=pools;
      for(let i=0;i<sPool.length&&n>0;i++){
        if(sData[i].life>0)continue; n--;
        const sp=sPool[i],d=sData[i]; const pos=new THREE.Vector3(); worldFromExhaust(group,exhaust,pos);
        sp.position.copy(pos); const s=1.4+Math.random()*2.4*boost; sp.scale.set(s,s,1);
        d.max=1.0+Math.random()*.9; d.life=d.max;
        const dir=new THREE.Vector3(-1,THREE.MathUtils.randFloatSpread(.25),THREE.MathUtils.randFloatSpread(.25)).applyQuaternion(group.quaternion);
        d.vel.copy(dir.multiplyScalar(3+2.2*boost)); sp.material.opacity=.35; sp.visible=true;
      }
    }
    function updatePools(pools, dt){
      const {fPool,fData,sPool,sData}=pools;
      for(let i=0;i<fPool.length;i++){
        const p=fPool[i],d=fData[i]; if(d.life<=0){p.visible=false;continue;}
        d.life-=dt; p.position.addScaledVector(d.vel,dt);
        const t=d.life/d.max; p.material.opacity=.18+.77*t;
        const s=(.7+1.9*(1-t)); p.scale.set(s,s,1);
        if(d.life<=0)p.visible=false;
      }
      for(let i=0;i<sPool.length;i++){
        const p=sPool[i],d=sData[i]; if(d.life<=0){p.visible=false;continue;}
        d.life-=dt; p.position.addScaledVector(d.vel,dt); p.position.y+=dt*.6;
        const t=d.life/d.max; p.material.opacity=.35*t;
        const s=p.scale.x*(1+.35*dt); p.scale.set(s,s,1);
        if(d.life<=0)p.visible=false;
      }
    }

    /* Camera (classic) */
    const camOff=new THREE.Vector3(-20,8.8,0), lookAhead=new THREE.Vector3(8,2,0);
    const camPos=new THREE.Vector3(), lookAt=new THREE.Vector3();
    function updateCamera(dt){
      const off=camOff.clone().applyQuaternion(ship.quaternion);
      camPos.copy(ship.position).add(off);
      camera.position.lerp(camPos,1-Math.pow(.0028,dt*60));
      const la=lookAhead.clone().applyQuaternion(ship.quaternion);
      lookAt.copy(ship.position).add(la); camera.lookAt(lookAt);
    }
    camera.position.copy(ship.position).add(camOff); camera.lookAt(ship.position.clone().add(lookAhead));

    /* Input (player) */
    let controlsEnabled=false;
    const keys={KeyW:false,KeyA:false,KeyS:false,KeyD:false};
    addEventListener('keydown',e=>{ if(!controlsEnabled) return; if(e.code in keys) keys[e.code]=true; });
    addEventListener('keyup',e=>{ if(!controlsEnabled) return; if(e.code in keys) keys[e.code]=false; });

    let lastX=null,lastY=null,yawVel=0,pitchVel=0; 
    const M_SENS_X=.00405, M_SENS_Y=.00345, YAW_D=.90, PITCH_D=.90, MAX_YAW=2.6;
    addEventListener('mousemove',e=>{
      if(!controlsEnabled||isTouch) return;
      if(lastX===null){lastX=e.clientX;lastY=e.clientY;return;}
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      lastX=e.clientX; lastY=e.clientY;
      yawVel  -=  dx * M_SENS_X;   // sağa -> sağa
      pitchVel += -dy * M_SENS_Y;  // yukarı -> pitch+
    }, {passive:true});
    addEventListener('mouseleave',()=>{lastX=lastY=null;}); addEventListener('blur',()=>{lastX=lastY=null;});

    /* Collisions */
    const SHIP_R = 1.1;
    function handlePlanetCollisions(group){
      for(const pl of planets){
        const r = (pl.userData.radius || pl.scale.x);
        const minD = (r*0.88) + SHIP_R;
        const toShip = tmpV.copy(group.position).sub(pl.position);
        const d = toShip.length();
        if(d < minD){
          toShip.normalize();
          group.position.copy(pl.position).addScaledVector(toShip, minD);
          return true;
        }
      }
      return false;
    }

    /* Movement (player) */
    let velF=0,yaw=0,pitch=0,throttle=0,prevThrottle=0,turnKeyVel=0;
    function updateShip(dt){
      if(!controlsEnabled){ velF*=Math.pow(.94,dt*60); yawVel*=Math.pow(.92,dt*60); pitchVel*=Math.pow(.92,dt*60); updatePools(playerPools,dt); return; }
      let fwd=0, turnKey=0;
      if(!isTouch){ if(keys.KeyW)fwd+=1; if(keys.KeyS)fwd-=1; if(keys.KeyD)turnKey-=1; if(keys.KeyA)turnKey+=1; }

      yawVel*=Math.pow(YAW_D,dt*60); pitchVel*=Math.pow(PITCH_D,dt*60); turnKeyVel=THREE.MathUtils.damp(turnKeyVel,turnKey*1.2,6,dt);
      const yawRate=THREE.MathUtils.clamp((yawVel+turnKeyVel)*3.0,-MAX_YAW,MAX_YAW), pitchRate=THREE.MathUtils.clamp(pitchVel*3.0,-1.6,1.6);
      yaw+=yawRate*dt; pitch+=pitchRate*dt; pitch=clamp(pitch,-Math.PI/3,Math.PI/3);

      const ACC=26, MAX=26, DRAG_C=.985, DRAG_A=.96, DRAG_B=.90;
      const tTarget=Math.max(0,fwd); throttle += (tTarget-throttle)*(1-Math.pow(.2,dt*60)); velF+=throttle*ACC*dt; if(fwd<0) velF+=fwd*ACC*dt;
      const drag=(fwd<0)?DRAG_B:(throttle>.02?DRAG_A:DRAG_C); velF*=Math.pow(drag,dt*60); velF=clamp(velF,-MAX,MAX);

      const targetRoll=-(yawVel+turnKeyVel)*0.25; ship.rotation.set(pitch,yaw,THREE.MathUtils.damp(ship.rotation.z,targetRoll,8,dt));
      const forward=new THREE.Vector3(1,0,0).applyQuaternion(ship.quaternion);
      ship.position.addScaledVector(forward,velF*dt);
      ship.position.y=clamp(ship.position.y,-70,70);

      const collided = handlePlanetCollisions(ship);
      if(collided && velF>0) velF*=0.15;

      // player vs AI collisions
      for(const s of aiShips){
        const d = ship.position.distanceTo(s.group.position);
        if(d < SHIP_R*2){
          const n = ship.position.clone().sub(s.group.position).normalize();
          ship.position.addScaledVector(n, (SHIP_R*2 - d)*0.52);
          s.group.position.addScaledVector(n, -(SHIP_R*2 - d)*0.52);
          velF *= 0.6; s.velF *= 0.6;
          s.yaw += angleDelta(s.yaw, Math.atan2(-n.z, -n.x))*0.4;
        }
      }

      const speedAbs=Math.abs(velF);
      const rate=Math.floor(6+14*clamp(throttle+speedAbs/20,0,1.5));
      if(throttle>.01) spawnFlameAt(ship,exhaustLocal,playerPools,rate,clamp(throttle+speedAbs/30,.6,1.6));
      if(prevThrottle>.25 && throttle<=.02) spawnSmokeAt(ship,exhaustLocal,playerPools,24,1.4);
      if((throttle<=.02 && speedAbs>2) || fwd<0) spawnSmokeAt(ship,exhaustLocal,playerPools,2,1.0+(fwd<0?.6:0));
      prevThrottle=throttle;

      updatePools(playerPools,dt);
    }

    /* Overlay & Quick View */
    const qv=document.getElementById('quickview'), qvTitle=document.getElementById('qvTitle'),
          qvTag=document.getElementById('qvTag'), qvMedia=document.getElementById('qvMedia');
    let nearest=null;
    function updateCardsAndHint(){
      const W=innerWidth,H=innerHeight; let best=null,dmin=Infinity;
      for(const {el,obj,pill} of cardsRef){
        tmpV.copy(obj.position); tmpV.y+=10; tmpV.project(camera);
        const on=tmpV.z<1&&tmpV.z>-1; let x=(tmpV.x*.5+.5)*W,y=(-tmpV.y*.5+.5)*H;
        if(on){ x=clamp(x,18,W-18); y=clamp(y,80,H-96); el.style.left=x+'px'; el.style.top=y+'px';
          const dist=camera.position.distanceTo(obj.position); const a=THREE.MathUtils.clamp(1-(dist-60)/220,0,1);
          el.style.opacity=a; el.style.transform=`translate(-50%,-100%) scale(${0.92+a*0.1})`;
        } else { el.style.opacity=0; }
        const d=ship.position.distanceTo(obj.position); if(d<dmin){dmin=d; best=obj;}
        if(pill) pill.style.opacity=0;
      }
      const TH=28; nearest=(best&&dmin<TH)?best:null;
      if(nearest && controlsEnabled && !qv.classList.contains('show')){
        const ref=cardsRef.find(c=>c.obj===nearest); if(ref&&ref.pill){ ref.pill.style.opacity=1; }
      }
    }
    function qvOpenFor(pl){
      controlsEnabled=false;
      const p=pl.userData.project;
      qvTitle.textContent=p.title; qvTag.textContent=p.tag||'';
      qvMedia.style.backgroundImage=`url('${p.cover||''}')`;
      qv.style.display='flex';
      qv.classList.add('show');
      qv.setAttribute('aria-hidden','false');
    }
    function qvCloseFn(){
      qv.classList.remove('show');
      qv.style.display='none';
      qv.setAttribute('aria-hidden','true');
      controlsEnabled=true;
    }
    document.getElementById('qvExit').addEventListener('click',qvCloseFn);
    addEventListener('keydown',e=>{
      if(e.code==='KeyQ' && qv.classList.contains('show')){ qvCloseFn(); return; }
      if(e.code==='KeyE'){
        if(qv.classList.contains('show')){ window.location.href='projects.html'; }
        else if(controlsEnabled && nearest){ qvOpenFor(nearest); }
      }
    });

    /* ---------- AI SHIPS (smarter + collisions) ---------- */
    const AI_COUNT = 15;
    const aiShips=[];
    const SAFE_R   = 170;             // hedef seçim sınırı
    const ARRIVE_R = 26;              // yavaşlamaya başla
    const STOP_R   = 9;               // hedefe vardım
    const ORBIT_TIME = [2.5, 5.0];    // sn
    const DWELL_TIME = [1.2, 2.6];    // sn
    const BRAKE_WINDOW = [1.0, 2.2];  // rastgele coast/brake
    const SHIP_DIAM = SHIP_R * 2;

    function invertMaterialColors(obj){
      obj.traverse(n=>{
        if(n.isMesh && n.material){
          const mats = Array.isArray(n.material)? n.material : [n.material];
          mats.forEach(m=>{
            if(m.color){ m.color.setRGB(1-m.color.r, 1-m.color.g, 1-m.color.b); }
            if(m.emissive){ m.emissive.setRGB(1-m.emissive.r, 1-m.emissive.g, 1-m.emissive.b); m.emissiveIntensity = Math.max(0.5, (m.emissiveIntensity||0.2)*1.4); }
          });
        }
      });
    }

    function createAIShip(position){
      const group=new THREE.Group();
      let exhaust=new THREE.Vector3(-2,0,0);
      if(baseModel){
        const m = cloneSkeleton(baseModel);
        invertMaterialColors(m);
        const fit = fitModelToShip(m);
        exhaust.copy(fit.exhaustLocal);
        group.add(m);
      }else{
        const fb=new THREE.Mesh(new THREE.CapsuleGeometry(.6,2.4,6,12),
          new THREE.MeshStandardMaterial({color:0xff9ad4,roughness:.45,metalness:.25,emissive:0x281022,emissiveIntensity:.3}));
        fb.rotation.z=Math.PI/2; group.add(fb);
      }
      group.position.copy(position);
      scene.add(group);

      const pools=makeParticlePools(70,36);
      const state={
        group, exhaust, pools,
        speed: rand(9,16),
        yaw: rand(-Math.PI,Math.PI),
        pitch: rand(-0.2,0.2),
        velF: 0, throttle: 0,
        mode: 'travel',
        target: null,
        timer: 0,
        brakeTimer: 0,
        lastDist: Infinity, stuckTimer: 0
      };
      pickNextTarget(state, true);
      aiShips.push(state);
    }

    function clampInsideSphere(v, r){
      if(v.length() > r){ v.setLength(r-1e-3); }
      return v;
    }

    function pickNextTarget(s, first=false){
      if(Math.random() < 0.75 && planets.length){
        const pl = planets[Math.floor(Math.random()*planets.length)];
        const rp = (pl.userData.radius||12) + rand(6,14);
        const dir= new THREE.Vector3(rand(-1,1),rand(-.25,.25),rand(-1,1)).normalize();
        const pos= clampInsideSphere(pl.position.clone().addScaledVector(dir, rp), SAFE_R);
        s.target = { pos, planet: pl };
      }else{
        const R = rand(60,SAFE_R);
        const a = rand(0,TAU), h=rand(-30,30);
        s.target = { pos: new THREE.Vector3(Math.cos(a)*R, h, Math.sin(a)*R) };
      }
      s.mode = 'travel';
      if(first){
        s.group.lookAt(s.target.pos);
        s.yaw = s.group.rotation.y;
        s.pitch = s.group.rotation.x;
      }
      // rastgele fren aralığı
      s.brakeTimer = rand(...BRAKE_WINDOW);
      s.lastDist = Infinity; s.stuckTimer = 0;
    }

    function leashCenter(s){
      if(s.group.position.length() > SAFE_R*1.15){
        const back = s.group.position.clone().multiplyScalar(-1).setLength(rand(60,SAFE_R));
        back.y = clamp(back.y, -30, 30);
        s.target = { pos: back };
        s.mode = 'travel';
      }
    }

    function steerTravel(s, dt){
      const MAX = s.speed, ACC=18, DRAG=0.97;

      const to = s.target.pos.clone().sub(s.group.position);
      const dist = to.length();
      const dir = to.normalize();

      // stuck kontrolü
      if(Math.abs(s.lastDist - dist) < 0.05) s.stuckTimer += dt; else s.stuckTimer = 0;
      s.lastDist = dist;
      if(s.stuckTimer > 2.5){ pickNextTarget(s); return; }

      // yön
      const targetYaw   = Math.atan2(dir.z, dir.x);
      const targetPitch = Math.asin(clamp(dir.y, -0.99, 0.99));
      const dYaw   = angleDelta(s.yaw,   targetYaw)   + THREE.MathUtils.randFloatSpread(0.02);
      const dPitch = (targetPitch - s.pitch)          + THREE.MathUtils.randFloatSpread(0.015);
      s.yaw   = THREE.MathUtils.damp(s.yaw,   s.yaw   + dYaw,  5, dt);
      s.pitch = THREE.MathUtils.damp(s.pitch, s.pitch + dPitch,5, dt);
      s.pitch = clamp(s.pitch, -Math.PI/3, Math.PI/3);
      s.group.rotation.set(s.pitch, s.yaw, THREE.MathUtils.damp(s.group.rotation.z, -dYaw*0.18, 8, dt));

      // arrive hız hedefi
      const arriveT = clamp((dist - STOP_R) / (ARRIVE_R - STOP_R), 0, 1); // 0..1
      let targetSpeed = MAX * (0.25 + 0.75*arriveT); // yakında yavaşla

      // arada bilinçli coast/brake
      s.brakeTimer -= dt;
      if(s.brakeTimer <= 0){
        targetSpeed *= 0.5 + Math.random()*0.2; // kısa fren
        s.brakeTimer = rand(...BRAKE_WINDOW);
      }

      // hızlanma/fren
      s.velF = THREE.MathUtils.damp(s.velF, targetSpeed, 3.2, dt);
      s.velF *= Math.pow(DRAG, dt*60);

      // ilerle
      const forward = new THREE.Vector3(1,0,0).applyQuaternion(s.group.quaternion);
      s.group.position.addScaledVector(forward, s.velF*dt);
      s.group.position.y = clamp(s.group.position.y, -70, 70);

      // çarpışmalar
      if(handlePlanetCollisions(s.group) && s.velF>0){ s.velF*=0.25; }
    }

    function orbitOrDwell(s, dt){
      s.timer -= dt;
      if(s.mode==='dwell'){
        s.velF = THREE.MathUtils.damp(s.velF, 0, 6, dt);
        s.group.rotation.z = THREE.MathUtils.damp(s.group.rotation.z, 0, 6, dt);
      }else if(s.mode==='orbit' && s.target.planetRef){
        const pl = s.target.planetRef;
        const r  = (pl.userData.radius||12) + 6;
        const center = pl.position;
        const rel = s.group.position.clone().sub(center);
        const a = Math.atan2(rel.z, rel.x) + s.target.orbitDir * dt * 0.6;
        const y = THREE.MathUtils.clamp(rel.y + THREE.MathUtils.randFloatSpread(0.25), -10, 10);
        s.target.pos = new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r).add(center);
        // yumuşak itki
        s.velF = THREE.MathUtils.damp(s.velF, s.speed*0.35, 2.5, dt);
        s.group.lookAt(s.target.pos);
        s.yaw = THREE.MathUtils.damp(s.yaw, s.group.rotation.y, 6, dt);
        s.pitch = THREE.MathUtils.damp(s.pitch, s.group.rotation.x, 6, dt);
      }
      if(s.timer<=0) pickNextTarget(s);
    }

    function updateAI(dt){
      // AI hareket
      for(const s of aiShips){
        leashCenter(s);
        if(!s.target) { pickNextTarget(s); continue; }

        const dist = s.group.position.distanceTo(s.target.pos);
        if(s.mode==='travel'){
          steerTravel(s, dt);
          if(dist <= STOP_R){
            if(s.target.planet){
              s.mode = (Math.random()<0.55) ? 'dwell' : 'orbit';
              s.timer = (s.mode==='dwell' ? rand(...DWELL_TIME) : rand(...ORBIT_TIME));
              if(s.mode==='orbit'){ s.target.orbitDir = Math.random()<0.5 ? 1 : -1; s.target.planetRef = s.target.planet; }
            }else{
              pickNextTarget(s);
            }
          }
        } else {
          orbitOrDwell(s, dt);
        }
      }

      // AI↔AI ve Player↔AI çarpışmaları
      for(let i=0;i<aiShips.length;i++){
        const A = aiShips[i];
        // AI vs Player handled in player loop too; do double resolve for stability:
        let dP = A.group.position.distanceTo(ship.position);
        if(dP < SHIP_DIAM){
          const n = A.group.position.clone().sub(ship.position).normalize();
          const pen = (SHIP_DIAM - dP);
          A.group.position.addScaledVector(n, pen*0.55);
          ship.position.addScaledVector(n, -pen*0.45);
          A.velF *= 0.6; velF *= 0.6;
          A.yaw += angleDelta(A.yaw, Math.atan2(n.z, n.x))*0.35;
        }
        for(let j=i+1;j<aiShips.length;j++){
          const B = aiShips[j];
          const d = A.group.position.distanceTo(B.group.position);
          if(d < SHIP_DIAM){
            const n = A.group.position.clone().sub(B.group.position).normalize();
            const pen = (SHIP_DIAM - d);
            A.group.position.addScaledVector(n,  pen*0.5);
            B.group.position.addScaledVector(n, -pen*0.5);
            A.velF *= 0.85; B.velF *= 0.85;
            A.yaw += angleDelta(A.yaw, Math.atan2(n.z, n.x))*0.25;
            B.yaw += angleDelta(B.yaw, Math.atan2(-n.z, -n.x))*0.25;
          }
        }
        // parçacıklar
        const rate = Math.floor(4+12*clamp(A.velF/ A.speed, 0, 1.5));
        if(A.velF>0.5) spawnFlameAt(A.group, A.exhaust, A.pools, rate, clamp(A.velF/A.speed,.6,1.4));
        else if(A.velF<0.4) spawnSmokeAt(A.group, A.exhaust, A.pools, 1, 1.0);
        updatePools(A.pools, dt);
      }
    }

    /* Satellites (decoration) */
    const satellites=[], debrisPool=[];
    function makeSatellite(x,y,z){
      const group=new THREE.Group();
      const body=new THREE.Mesh(new THREE.BoxGeometry(1.0,0.8,0.6), new THREE.MeshStandardMaterial({color:0xd0d6e5,metalness:.4,roughness:.6}));
      const panelMat=new THREE.MeshStandardMaterial({color:0x6aa7ff,emissive:0x0e1a44,emissiveIntensity:.4,roughness:.4});
      const panelL=new THREE.Mesh(new THREE.BoxGeometry(2.0,0.1,1.0), panelMat);
      const panelR=panelL.clone(); panelL.position.set(-1.5,0,0); panelR.position.set(1.5,0,0);
      group.add(body,panelL,panelR);
      group.position.set(x,y,z); group.scale.setScalar(3);
      group.userData.spin = THREE.MathUtils.randFloat(0.3,0.8);
      scene.add(group); satellites.push(group);
    }
    for(let i=0;i<5;i++){
      const a=Math.random()*Math.PI*2, r=THREE.MathUtils.randFloat(50,120);
      makeSatellite(Math.cos(a)*r, THREE.MathUtils.randFloatSpread(12), Math.sin(a)*r);
    }
    function spawnDebris(at){
      for(let i=0;i<12;i++){
        const cube=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.12,0.12), new THREE.MeshStandardMaterial({color:0x9fb4ff,metalness:.3,roughness:.4,transparent:true,opacity:1}));
        cube.position.copy(at);
        const vel=new THREE.Vector3(THREE.MathUtils.randFloatSpread(6), THREE.MathUtils.randFloatSpread(4)+1.2, THREE.MathUtils.randFloatSpread(6));
        const life=1.6+Math.random()*0.9;
        debrisPool.push({mesh:cube, vel, life, max:life});
        scene.add(cube);
      }
    }
    function updateSatellites(dt){
      for(const s of satellites){ s.rotation.y += s.userData.spin*dt; }
      for(let i=satellites.length-1;i>=0;i--){
        const s=satellites[i];
        if(ship.position.distanceTo(s.position) < 3.0){
          spawnDebris(s.position); scene.remove(s); satellites.splice(i,1);
        }
      }
      for(let i=debrisPool.length-1;i>=0;i--){
        const d=debrisPool[i]; d.life-=dt;
        d.mesh.position.addScaledVector(d.vel,dt); d.vel.multiplyScalar(0.985); d.mesh.rotation.x+=dt*2; d.mesh.rotation.y+=dt*2.4;
        const t=Math.max(0,d.life/d.max); d.mesh.material.opacity = t;
        if(d.life<=0){ scene.remove(d.mesh); debrisPool.splice(i,1); }
      }
    }

    /* Start */
    const startEl=document.getElementById('start');
    document.getElementById('btnStart').addEventListener('click',()=>{
      startEl.classList.add('hide');
      setTimeout(()=>{ controlsEnabled=true; },550);
    });

    /* Loop */
    addEventListener('resize',()=>{renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();});
    const clock=new THREE.Clock();
    function loop(){
      const dt=Math.min(.033,clock.getDelta());
      // player
      let before = ship.position.clone();
      updateShip(dt); updateCamera(dt);
      // gezegen spin
      for(const pl of planets){ pl.rotation.y += (pl.userData.spin||0.03)*dt*0.5; }
      // AI
      updateAI(dt);
      // overlay
      updateCardsAndHint();
      renderer.render(scene,camera); requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
