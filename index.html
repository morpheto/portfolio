<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Orhun Ege Eker — Space Portfolio</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#05060a; --text:#f6f7fb; --muted:#cbd5e1; --accent:#1e5eff; }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
  canvas#scene{position:fixed;inset:0;width:100%;height:100%;display:block}

  /* HUD */
  .hud{position:fixed;top:12px;left:12px;right:12px;z-index:20;display:flex;justify-content:space-between;align-items:center;padding:10px 14px;background:rgba(8,10,18,.45);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(8px);border-radius:16px}
  .brand{font-weight:800;letter-spacing:.4px;font-size:16px}
  .nav{display:flex;gap:16px}
  .nav a{color:var(--text);text-decoration:none;opacity:.9;font-size:14px}

  .help{position:fixed;right:12px;bottom:12px;z-index:20;color:var(--muted);font-size:12px;padding:10px 12px;border:1px solid rgba(255,255,255,.12);border-radius:12px;background:rgba(255,255,255,.06);backdrop-filter:blur(6px)}

  /* Overlay cards */
  .overlay{position:fixed;inset:0;pointer-events:none;z-index:12}
  .planet-card{position:absolute;transform:translate(-50%,-100%);width:240px;max-width:40vw;border-radius:12px;overflow:hidden;border:1px solid rgba(120,198,255,.28);background:linear-gradient(180deg, rgba(20,24,40,.85), rgba(10,12,20,.9));box-shadow:0 10px 26px rgba(0,0,0,.45);transition:opacity .15s ease, transform .15s ease;opacity:.0; pointer-events:auto}
  .planet-card__media{position:relative;height:120px;background:#0f1430;background-size:cover;background-position:center}
  .planet-card__meta{display:flex;justify-content:space-between;align-items:center;padding:8px 10px}
  .title{font-weight:700}
  .badge{position:absolute;left:8px;top:8px;background:rgba(64,191,255,.12);border:1px solid rgba(64,191,255,.4);backdrop-filter:blur(6px);font-size:11px;padding:6px 8px;border-radius:999px;color:#cfefff}
  .enter-pill{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);padding:6px 10px;border-radius:999px;border:1px solid rgba(120,198,255,.35);background:rgba(64,191,255,.10);color:#dff2ff;font-size:12px;box-shadow:0 0 16px rgba(64,191,255,.25);opacity:0;transition:opacity .15s ease;pointer-events:none}

  /* Quick View */
  .popup{position:fixed;inset:0;z-index:60;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(4px)}
  .popup.show{display:flex}
  .popup-card{width:min(820px,92vw);border:1px solid rgba(120,198,255,.28);border-radius:16px;background:#0b0f1c;box-shadow:0 20px 60px rgba(0,0,0,.55);overflow:hidden}
  .popup-media{height:min(52vh,460px);background:#0e1433;background-size:cover;background-position:center}
  .popup-body{padding:12px 14px;display:flex;align-items:center;justify-content:space-between;gap:10px}
  .popup-title{font-weight:800;font-size:18px}.popup-tag{font-size:12px;color:#cfd6e3}
  .popup-actions{display:flex;gap:10px}
  .btn{padding:10px 14px;border-radius:10px;border:1px solid rgba(120,198,255,.3);background:#10172b;color:#fff;font-size:14px;cursor:pointer}
  .btn.primary{background:var(--accent);border-color:#2b66ff}

  /* Start */
  .start{position:fixed;inset:0;z-index:50;display:flex;align-items:center;justify-content:center;background:radial-gradient(1200px 600px at 50% -20%, rgba(120,170,255,.08), rgba(5,6,10,.95))}
  .start.hide{animation:fade .6s both}@keyframes fade{to{opacity:0;visibility:hidden}}
  .start-card{padding:22px 24px;border:1px solid rgba(255,255,255,.12);background:rgba(10,12,20,.72);backdrop-filter:blur(8px);border-radius:16px;display:flex;flex-direction:column;gap:10px;align-items:center;min-width:260px; transform:translateZ(0)}
  .start-card h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px;text-align:center}
  .start-sub{margin:0 0 8px;font-size:12px;color:#d0d7e4;opacity:.92;text-align:center}
  .kbd{font-weight:700;border:1px solid rgba(255,255,255,.18);padding:2px 6px;border-radius:6px;background:rgba(255,255,255,.06)}
  .actions{display:flex;gap:10px;margin-top:4px;flex-wrap:wrap;justify-content:center}
  .btn.linklike{background:transparent}

  /* Mobile gate */
  .mobile-gate{position:fixed;inset:0;z-index:70;display:none;align-items:center;justify-content:center;background:radial-gradient(800px 400px at 50% 50%, rgba(120,170,255,.12), rgba(5,6,10,.95));backdrop-filter:blur(6px)}
  .mobile-card{padding:24px 28px;border:1px solid rgba(255,255,255,.18);background:linear-gradient(180deg, rgba(20,24,40,.9), rgba(10,12,20,.95));border-radius:20px;max-width:360px;text-align:center;box-shadow:0 8px 24px rgba(0,0,0,.4)}
  .mobile-card h2{margin:0 0 10px;font-size:20px;font-weight:700;color:#e0e7ff}
  .mobile-card p{margin:0 0 16px;font-size:15px;color:#d0d7e4;line-height:1.5}
  .mobile-card .btn.primary{padding:12px 20px;font-size:15px;border-radius:12px}
</style>
</head>
<body>
  <div class="hud">
    <div class="brand">ORHUN EGE EKER</div>
    <div class="nav">
      <a href="index.html">SPACE</a>
      <a href="projects.html">PROJECTS</a>
      <a href="about.html">ABOUT</a>
      <a href="contact.html">CONTACT</a>
    </div>
  </div>

  <div class="help" id="helpBox">Loading controls…</div>
  <div class="overlay" id="overlay"></div>

  <!-- Quick View -->
  <div class="popup" id="quickview" aria-hidden="true">
    <div class="popup-card" role="dialog" aria-modal="true">
      <div class="popup-media" id="qvMedia"></div>
      <div class="popup-body">
        <div>
          <div class="popup-title" id="qvTitle">Project</div>
          <div class="popup-tag" id="qvTag">Category</div>
        </div>
        <div class="popup-actions">
          <a class="btn primary" id="qvEnter" href="projects.html">View in Portfolio (E)</a>
          <button class="btn" id="qvExit" type="button">Quit (Q)</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Start -->
  <div class="start" id="start">
    <div class="start-card">
      <h1>Orhun Ege Eker — Space Tour</h1>
      <div class="start-sub">Explore projects in a tiny galaxy</div>
      <div class="actions">
        <a class="btn linklike" href="projects.html">Basic Portfolio</a>
        <button id="btnStart" class="btn primary" type="button">Start</button>
      </div>
      <p style="margin:8px 0 0;font-size:12px;opacity:.85">
        <span class="kbd">W/S</span> move · mouse turn · near planet <span class="kbd">E</span> enter
      </p>
    </div>
  </div>

  <!-- Mobile gate -->
  <div class="mobile-gate" id="mobileGate">
    <div class="mobile-card">
      <h2>Hey there!</h2>
      <p>This space adventure is best enjoyed on a computer for now. Want to check out my projects? Hop over to the basic portfolio instead!</p>
      <a class="btn primary" href="projects.html">Explore Basic Portfolio</a>
    </div>
  </div>

  <canvas id="scene"></canvas>

  <!-- Import map: three & addons -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <!-- App (module) -->
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const isTouch = matchMedia('(pointer:coarse)').matches || ('ontouchstart' in window);
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const angleDiff=(a,b)=>{
      let d = (a-b) % (Math.PI*2);
      if(d<-Math.PI) d+=Math.PI*2;
      if(d> Math.PI) d-=Math.PI*2;
      return d;
    };

    /* ----- Mobile gate ----- */
    const mobileGate = document.getElementById('mobileGate');
    if (isTouch) { mobileGate.style.display = 'flex'; }

    /* HUD help */
    const helpBox=document.getElementById('helpBox');
    helpBox.innerHTML = isTouch
      ? '<b>Mobile</b> — This space tour shines on desktop! Try the Basic Portfolio for now.'
      : '<b>Desktop</b> — Mouse move: turn · <b>W/S</b> forward/back · <b>A/D</b> turn · Near planet: <b>E</b> enter · In modal: <b>Q</b> exit';

    /* Blue/cyan exhaust textures */
    function makeRadialTexture(inner, outer, size=128){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const ctx=c.getContext('2d'); const g=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
      g.addColorStop(0,inner); g.addColorStop(1,outer); ctx.fillStyle=g; ctx.fillRect(0,0,size,size);
      const t=new THREE.CanvasTexture(c); t.minFilter=THREE.LinearFilter; t.magFilter=THREE.LinearFilter; return t;
    }
    const flameTex = makeRadialTexture('rgba(120,230,255,1)','rgba(0,170,255,0)');
    const smokeTex = makeRadialTexture('rgba(160,210,255,0.55)','rgba(90,140,200,0)');

    /* Scene */
    const renderer = new THREE.WebGLRenderer({canvas:document.getElementById('scene'), antialias:true});
    renderer.setPixelRatio(Math.min(2, devicePixelRatio||1)); renderer.setSize(innerWidth, innerHeight);
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x05060a);
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 6000);

    scene.add(new THREE.HemisphereLight(0x89b4ff, 0x05060a, .55));
    const sun = new THREE.DirectionalLight(0xffffff,.85); sun.position.set(160,220,120); scene.add(sun);

    /* Stars */
    (function(){
      const g=new THREE.BufferGeometry(), N=2500, pos=new Float32Array(N*3);
      for(let i=0;i<N;i++){const R=900+Math.random()*1400, th=Math.random()*Math.PI*2, u=Math.random()*2-1, s=Math.sqrt(1-u*u);
        pos[i*3]=R*s*Math.cos(th); pos[i*3+1]=R*u*0.7; pos[i*3+2]=R*s*Math.sin(th);} 
      g.setAttribute('position', new THREE.BufferAttribute(pos,3));
      scene.add(new THREE.Points(g,new THREE.PointsMaterial({size:1.6,color:0xbfd9ff,sizeAttenuation:true})));
    })();

    /* Galaxies (far sprites) */
    (function(){
      const galaxies = [];
      function galaxyTexture(){
        const s=256, c=document.createElement('canvas'); c.width=c.height=s; const ctx=c.getContext('2d');
        const g=ctx.createRadialGradient(s/2,s/2,4,s/2,s/2,s/2);
        g.addColorStop(0,'rgba(255,255,255,.9)');
        g.addColorStop(.3,'rgba(180,210,255,.55)');
        g.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=g; ctx.fillRect(0,0,s,s);
        return new THREE.CanvasTexture(c);
      }
      const tex = galaxyTexture();
      for(let i=0;i<6;i++){
        const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false,opacity:.9}));
        const R=800+Math.random()*800, a=Math.random()*Math.PI*2, h=THREE.MathUtils.randFloatSpread(200);
        sp.position.set(Math.cos(a)*R,h,Math.sin(a)*R); sp.scale.setScalar(120+Math.random()*120);
        sp.material.opacity = .35 + Math.random()*.25;
        scene.add(sp); galaxies.push(sp);
      }
    })();

    /* Black hole (simple) */
    (function(){
      const disk = new THREE.Mesh(
        new THREE.TorusGeometry(28, 5.2, 2, 100),
        new THREE.MeshStandardMaterial({color:0x6aa7ff, emissive:0x1534a6, emissiveIntensity:.8, metalness:.2, roughness:.4, side:THREE.DoubleSide, transparent:true, opacity:.5})
      );
      disk.rotation.x = Math.PI/2;
      disk.position.set(-260, -40, -120);
      scene.add(disk);
      const s=256, c=document.createElement('canvas'); c.width=c.height=s; const ctx=c.getContext('2d');
      const g=ctx.createRadialGradient(s/2,s/2,0,s/2,s/2,s/2);
      g.addColorStop(0,'rgba(0,0,0,1)'); g.addColorStop(.6,'rgba(0,0,0,.8)'); g.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(s/2,s/2,s/2,0,Math.PI*2); ctx.fill();
      const bhTex=new THREE.CanvasTexture(c);
      const core=new THREE.Sprite(new THREE.SpriteMaterial({map:bhTex,transparent:true,depthWrite:false,opacity:.9}));
      core.position.copy(disk.position); core.scale.setScalar(80); scene.add(core);
      const spin = ()=>{ disk.rotation.z += 0.0016; requestAnimationFrame(spin); }; spin();
    })();

    /* Planet textures (procedural) */
    function createMoonTexture(){ const size=1024, c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      ctx.fillStyle='#777'; ctx.fillRect(0,0,size,size);
      for(let i=0;i<200;i++){const x=Math.random()*size, y=Math.random()*size, r=8+Math.random()*40;
        const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,'#555'); g.addColorStop(0.6,'#666'); g.addColorStop(1,'rgba(100,100,100,0.4)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();}
      for(let i=0;i<50;i++){const x=Math.random()*size, y=Math.random()*size, r=20+Math.random()*60;
        const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,'#444'); g.addColorStop(1,'rgba(50,50,50,0.3)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();}
      return new THREE.CanvasTexture(c);
    }
    function createMoonHeight(){ const size=1024, c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      ctx.fillStyle='#000'; ctx.fillRect(0,0,size,size);
      for(let i=0;i<200;i++){const x=Math.random()*size, y=Math.random()*size, r=8+Math.random()*40;
        const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,'#fff'); g.addColorStop(0.6,'#aaa'); g.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();}
      return new THREE.CanvasTexture(c);
    }
    function createRockyTexture(){ const size=1024, c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      ctx.fillStyle='#8b4513'; ctx.fillRect(0,0,size,size);
      for(let i=0;i<150;i++){const x=Math.random()*size, y=Math.random()*size, r=10+Math.random()*30;
        const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,'#a0522d'); g.addColorStop(1,'rgba(139,69,19,0.3)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();}
      for(let i=0;i<50;i++){const x=Math.random()*size, y=Math.random()*size, r=15+Math.random()*50;
        const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,'#cd853f'); g.addColorStop(1,'rgba(205,133,63,0.2)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();}
      return new THREE.CanvasTexture(c);
    }
    function createRockyHeight(){ const size=1024, c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      ctx.fillStyle='#000'; ctx.fillRect(0,0,size,size);
      for(let i=0;i<150;i++){const x=Math.random()*size, y=Math.random()*size, r=10+Math.random()*30;
        const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,'#fff'); g.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();}
      return new THREE.CanvasTexture(c);
    }
    function createGasTexture(){ const size=1024, c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      const g=ctx.createLinearGradient(0,0,0,size);
      g.addColorStop(0,'#4682b4'); g.addColorStop(0.3,'#87ceeb'); g.addColorStop(0.7,'#4682b4'); g.addColorStop(1,'#20b2aa');
      ctx.fillStyle=g; ctx.fillRect(0,0,size,size);
      for(let i=0;i<80;i++){const x=Math.random()*size, y=Math.random()*size, r=30+Math.random()*60;
        ctx.fillStyle='rgba(255,255,255,0.15)'; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();}
      for(let i=0;i<40;i++){const x=Math.random()*size, y=Math.random()*size, r=20+Math.random()*40;
        ctx.fillStyle='rgba(0,0,0,0.1)'; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();}
      return new THREE.CanvasTexture(c);
    }
    function createGasHeight(){ const size=1024, c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      ctx.fillStyle='#000'; ctx.fillRect(0,0,size,size);
      const g=ctx.createLinearGradient(0,0,0,size);
      g.addColorStop(0,'#888'); g.addColorStop(0.5,'#ccc'); g.addColorStop(1,'#888');
      ctx.fillStyle=g; ctx.fillRect(0,0,size,size);
      for(let i=0;i<80;i++){const x=Math.random()*size, y=Math.random()*size, r=30+Math.random()*60;
        ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();}
      return new THREE.CanvasTexture(c);
    }
    const moonTex=createMoonTexture(), moonDisp=createMoonHeight();
    const rockyTex=createRockyTexture(), rockyDisp=createRockyHeight();
    const gasTex=createGasTexture(), gasDisp=createGasHeight();

    /* Projects -> planet cards */
    const PROJECTS=[
      {id:'p1',title:'Audio Reactive + Hand Tracked Visualizer',tag:'TouchDesigner',cover:'media/covers/p1.jpg',type:'moon'},
      {id:'p2',title:'Odin Pendant Animation',tag:'3D Works',cover:'media/covers/p2.jpg',type:'rocky'},
      {id:'p3',title:'MediaPipe + Ableton + PointCloud',tag:'Interactive',cover:'media/covers/p3.jpg',type:'gas'},
      {id:'p4',title:'Nike Air Jordan CGI',tag:'CGI',cover:'media/covers/p4.jpg',type:'rocky'},
      {id:'p5',title:'Bic Mini Lighter Spider Case',tag:'Product CGI',cover:'media/covers/p5.jpg',type:'moon'},
      {id:'p6',title:'Space Keycap Animation',tag:'3D Works',cover:'media/covers/p6.jpg',type:'gas'},
      {id:'p7',title:'Oxidized Silver Jewelry — Maverick',tag:'LookDev',cover:'media/covers/p7.jpg',type:'rocky'},
      {id:'p8',title:'YouTube Channel Intro',tag:'Motion · Audio',cover:'media/covers/p8.jpg',type:'moon'},
      {id:'p9',title:'AI Visualizer from Image',tag:'AI Visuals',cover:'media/covers/p9.jpg',type:'gas'}
    ];
    function appearanceFor(p){
      if(p.type==='moon') return {h:0.0,s:0.1,l:0.4,metal:0.2,rough:0.8,ring:false,emiss:0.1,texture:moonTex,disp:moonDisp};
      if(p.type==='rocky') return {h:0.08,s:0.5,l:0.3,metal:0.3,rough:0.7,ring:Math.random()<0.25,emiss:0.1,texture:rockyTex,disp:rockyDisp};
      if(p.type==='gas') return {h:0.58,s:0.6,l:0.5,metal:0.1,rough:0.9,ring:Math.random()<0.35,emiss:0.3,texture:gasTex,disp:gasDisp};
      return {h:0.66,s:0.40,l:0.58,metal:0.22,rough:0.55,ring:Math.random()<0.5,emiss:0.18,texture:null,disp:null};
    }

    const overlay=document.getElementById('overlay');
    const planets=[], cardsRef=[], tmpV=new THREE.Vector3();
    const sphereGeo=new THREE.SphereGeometry(1,64,48); // yüksek subdiv.
    function makePlanet(r,app){
      const col=new THREE.Color().setHSL(app.h,app.s,app.l);
      const m=new THREE.Mesh(sphereGeo,new THREE.MeshStandardMaterial({
        color:col.getHex(), roughness:app.rough, metalness:app.metal,
        emissive:col.clone().multiplyScalar(app.emiss).getHex(), emissiveIntensity:1,
        map:app.texture,
        displacementMap:app.disp, displacementScale:0.15,
        normalMap:app.disp, normalScale: new THREE.Vector2(0.8,0.8)
      }));
      m.rotation.z = THREE.MathUtils.degToRad(THREE.MathUtils.randFloatSpread(12));
      if(app.ring){
        const ring=new THREE.Mesh(
          new THREE.RingGeometry(r*1.02,r*1.08,64),
          new THREE.MeshBasicMaterial({color:col.clone().offsetHSL(.08,0,0).getHex(),transparent:true,opacity:.10,side:THREE.DoubleSide})
        );
        ring.rotation.x=-Math.PI/2 + THREE.MathUtils.randFloatSpread(.28);
        ring.rotation.z=Math.random()*Math.PI*2; m.add(ring);
      }
      m.scale.setScalar(r); m.userData.spin=THREE.MathUtils.randFloat(0.02,0.05);
      m.userData.radius=r; // çarpışma için
      return m;
    }
    const POS=[], RMIN=70, RMAX=150;
    for(let i=0;i<PROJECTS.length;i++){const R=THREE.MathUtils.randFloat(RMIN,RMAX), th=(i/PROJECTS.length)*Math.PI*2+Math.random()*0.6;
      POS.push([Math.cos(th)*R+THREE.MathUtils.randFloatSpread(20), THREE.MathUtils.randFloatSpread(18), Math.sin(th)*R+THREE.MathUtils.randFloatSpread(20)]);} 
    for(let i=POS.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [POS[i],POS[j]]=[POS[j],POS[i]];}
    PROJECTS.forEach((p,i)=>{
      const r=THREE.MathUtils.randFloat(9,16), app=appearanceFor(p), m=makePlanet(r,app); const [x,y,z]=POS[i];
      m.position.set(x,y,z); m.userData.project=p; scene.add(m); planets.push(m);
      const el=document.createElement('div'); el.className='planet-card';
      const cover=p.cover?`background-image:url('${p.cover}')`:`background-image:none`;
      el.innerHTML=`<div class="planet-card__media" style="${cover}">
        <div class="badge">${p.tag||''}</div>
        <div class="enter-pill">Press <b>E</b> to Enter</div>
      </div>
      <div class="planet-card__meta"><div class="title">${p.title}</div></div>`;
      overlay.appendChild(el);
      const pill=el.querySelector('.enter-pill');
      const item={el,obj:m,pill}; el.addEventListener('click',()=>{ if(nearest===m) qvOpenFor(m); }); cardsRef.push(item);
    });

    /* Ship & particles (player) */
    const ship=new THREE.Group(); scene.add(ship);
    const SHIP_RADIUS=2.4; // çarpışma kabaca

    // Fallback hull
    const hull=new THREE.Mesh(new THREE.CapsuleGeometry(.8,3,6,12),
      new THREE.MeshStandardMaterial({color:0x9aa7ff,roughness:.55,metalness:.2,emissive:0x10163a,emissiveIntensity:.2}));
    hull.rotation.z=Math.PI/2; ship.add(hull);

    // GLB (media/spaceship.glb) — +X yönüne çevir
    const loader = new GLTFLoader();
    let exhaustLocal=new THREE.Vector3(-2,0,0);
    let baseModel=null;

    function cloneSkeleton(src){
      const obj = src.clone(true);
      obj.traverse(n=>{
        if(n.isMesh){
          n.material = n.material.clone();
          if(n.skeleton){ n.skeleton = n.skeleton.clone(); }
        }
      });
      return obj;
    }
    function fitModelToShip(model){
      const box0 = new THREE.Box3().setFromObject(model);
      const size0 = new THREE.Vector3(); box0.getSize(size0);
      const s = 6 / Math.max(size0.x,size0.y,size0.z || 1);
      model.scale.setScalar(s);
      model.rotation.set(0, Math.PI/2, 0); // +Z → +X
      const b1 = new THREE.Box3().setFromObject(model);
      const c1 = new THREE.Vector3(); b1.getCenter(c1);
      model.position.sub(c1);
      const b2 = new THREE.Box3().setFromObject(model);
      const info = { exhaustLocal: new THREE.Vector3(b2.min.x - 0.6, 0, 0) };
      return info;
    }

    loader.load('media/spaceship.glb', (gltf)=>{
      baseModel = gltf.scene || gltf.scenes?.[0];
      if(baseModel){
        ship.clear();
        const m = cloneSkeleton(baseModel);
        const info = fitModelToShip(m);
        exhaustLocal.copy(info.exhaustLocal);
        ship.add(m);
      }
      spawnAIShips(); // <- ARTIK VAR
    }, undefined, ()=>{ spawnAIShips(); });

    function worldFromExhaust(out, carrier=ship, exhaust=exhaustLocal){return out.copy(exhaust).applyQuaternion(carrier.quaternion).add(carrier.position);}
    function makeSprite(mat){const s=new THREE.Sprite(mat.clone()); s.visible=false; scene.add(s); return s;}
    const flameMat=new THREE.SpriteMaterial({map:flameTex,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,opacity:.95});
    const smokeMat=new THREE.SpriteMaterial({map:smokeTex,transparent:true,depthWrite:false,opacity:.0});
    const flamePool=[...Array(140)].map(()=>makeSprite(flameMat)), smokePool=[...Array(100)].map(()=>makeSprite(smokeMat));
    const flameData=flamePool.map(()=>({life:0,max:0,vel:new THREE.Vector3()})), smokeData=smokePool.map(()=>({life:0,max:0,vel:new THREE.Vector3()}));
    function spawnFlame(n,intensity=1){
      for(let i=0;i<flamePool.length&&n>0;i++){
        if(flameData[i].life>0)continue; n--;
        const sp=flamePool[i],d=flameData[i]; const pos=new THREE.Vector3(); worldFromExhaust(pos);
        sp.position.copy(pos); sp.scale.setScalar(1.0+Math.random()*1.6*intensity);
        d.max=.38+Math.random()*.28; d.life=d.max;
        const dir=new THREE.Vector3(-1,THREE.MathUtils.randFloatSpread(.35),THREE.MathUtils.randFloatSpread(.35)).applyQuaternion(ship.quaternion);
        d.vel.copy(dir.multiplyScalar(13+20*intensity)); sp.material.opacity=.95; sp.visible=true;
      }
    }
    function spawnSmoke(n,boost=1){
      for(let i=0;i<smokePool.length&&n>0;i++){
        if(smokeData[i].life>0)continue; n--;
        const sp=smokePool[i],d=smokeData[i]; const pos=new THREE.Vector3(); worldFromExhaust(pos);
        sp.position.copy(pos); const s=1.4+Math.random()*2.4*boost; sp.scale.set(s,s,1);
        d.max=1.0+Math.random()*.9; d.life=d.max;
        const dir=new THREE.Vector3(-1,THREE.MathUtils.randFloatSpread(.25),THREE.MathUtils.randFloatSpread(.25)).applyQuaternion(ship.quaternion);
        d.vel.copy(dir.multiplyScalar(3+2.2*boost)); sp.material.opacity=.35; sp.visible=true;
      }
    }
    function updateParticles(dt){
      for(let i=0;i<flamePool.length;i++){
        const p=flamePool[i],d=flameData[i]; if(d.life<=0){p.visible=false;continue;}
        d.life-=dt; p.position.addScaledVector(d.vel,dt);
        const t=d.life/d.max; p.material.opacity=.18+.77*t;
        const s=(.7+1.9*(1-t)); p.scale.set(s,s,1);
        if(d.life<=0)p.visible=false;
      }
      for(let i=0;i<smokePool.length;i++){
        const p=smokePool[i],d=smokeData[i]; if(d.life<=0){p.visible=false;continue;}
        d.life-=dt; p.position.addScaledVector(d.vel,dt); p.position.y+=dt*.6;
        const t=d.life/d.max; p.material.opacity=.35*t;
        const s=p.scale.x*(1+.35*dt); p.scale.set(s,s,1);
        if(d.life<=0)p.visible=false;
      }
    }

    /* Camera (omuz üstü klasik açı) */
    const camOff=new THREE.Vector3(-20,8.8,0), lookAhead=new THREE.Vector3(8,2,0), camPos=new THREE.Vector3(), lookAt=new THREE.Vector3();
    function updateCamera(dt){
      const off=camOff.clone().applyQuaternion(ship.quaternion);
      camPos.copy(ship.position).add(off);
      camera.position.lerp(camPos,1-Math.pow(.0028,dt*60));
      const la=lookAhead.clone().applyQuaternion(ship.quaternion);
      lookAt.copy(ship.position).add(la); camera.lookAt(lookAt);
    }
    camera.position.copy(ship.position).add(camOff); camera.lookAt(ship.position.clone().add(lookAhead));

    /* Input */
    let controlsEnabled=false;
    const keys={KeyW:false,KeyA:false,KeyS:false,KeyD:false};
    addEventListener('keydown',e=>{ if(!controlsEnabled) return; if(e.code in keys) keys[e.code]=true; });
    addEventListener('keyup',e=>{ if(!controlsEnabled) return; if(e.code in keys) keys[e.code]=false; });

    // Mouse — ship’e göre
    let yawVel=0,pitchVel=0;
    let lastX=null,lastY=null;
    const M_SENS_X=.0048, M_SENS_Y=.0042, YAW_D=.90, PITCH_D=.90, MAX_YAW=2.8;
    addEventListener('mousemove',e=>{
      if(!controlsEnabled||isTouch) return;
      if(lastX===null){ lastX=e.clientX; lastY=e.clientY; return; }
      const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
      // Mouse sağ → sağ, yukarı → yukarı olacak şekilde:
      yawVel   += dx * M_SENS_X;      // +dx sağ, sağa rota
      pitchVel += -dy * M_SENS_Y;     // +dy aşağı -> negatif pitch (aşağı), biz tersliyoruz
    }, {passive:true});
    addEventListener('mouseleave',()=>{lastX=lastY=null;}); addEventListener('blur',()=>{lastX=lastY=null;});

    /* Movement (player) */
    let velF=0,yaw=0,pitch=0,throttle=0,prevThrottle=0,turnKeyVel=0;
    function updateShip(dt){
      if(!controlsEnabled){ velF*=Math.pow(.94,dt*60); yawVel*=Math.pow(.92,dt*60); pitchVel*=Math.pow(.92,dt*60); updateParticles(dt); return; }
      let fwd=0, turnKey=0;
      if(!isTouch){ if(keys.KeyW)fwd+=1; if(keys.KeyS)fwd-=1; if(keys.KeyD)turnKey-=1; if(keys.KeyA)turnKey+=1; }

      yawVel*=Math.pow(YAW_D,dt*60); pitchVel*=Math.pow(PITCH_D,dt*60); 
      turnKeyVel=THREE.MathUtils.damp(turnKeyVel,turnKey*1.2,6,dt);

      const yawRate=THREE.MathUtils.clamp((yawVel+turnKeyVel)*3.0,-MAX_YAW,MAX_YAW);
      const pitchRate=THREE.MathUtils.clamp(pitchVel*3.0,-1.6,1.6);
      yaw+=yawRate*dt; 
      pitch+=pitchRate*dt; 
      pitch=clamp(pitch,-Math.PI/3,Math.PI/3);

      const ACC=26, MAX=26, DRAG_C=.985, DRAG_A=.96, DRAG_B=.90;
      const tTarget=Math.max(0,fwd); throttle += (tTarget-throttle)*(1-Math.pow(.2,dt*60)); 
      velF+=throttle*ACC*dt; if(fwd<0) velF+=fwd*ACC*dt;
      const drag=(fwd<0)?DRAG_B:(throttle>.02?DRAG_A:DRAG_C); velF*=Math.pow(drag,dt*60); velF=clamp(velF,-MAX,MAX);

      const targetRoll=-(yawVel+turnKeyVel)*0.25; ship.rotation.set(pitch,yaw,THREE.MathUtils.damp(ship.rotation.z,targetRoll,8,dt));
      const forward=new THREE.Vector3(1,0,0).applyQuaternion(ship.quaternion); ship.position.addScaledVector(forward,velF*dt);
      ship.position.y += Math.sin(pitch)*velF*.75*dt; ship.position.y=clamp(ship.position.y,-70,70);

      const speedAbs=Math.abs(velF);
      const rate=Math.floor(6+14*clamp(throttle+speedAbs/20,0,1.5));
      if(throttle>.01) spawnFlame(rate,clamp(throttle+speedAbs/30,.6,1.6));
      if(prevThrottle>.25 && throttle<=.02) spawnSmoke(24,1.4);
      if((throttle<=.02 && speedAbs>2) || fwd<0) spawnSmoke(2,1.0+(fwd<0?.6:0));
      prevThrottle=throttle;

      updateParticles(dt);
    }

    /* Overlay & hint (Quick View) */
    const qv=document.getElementById('quickview'), qvTitle=document.getElementById('qvTitle'),
          qvTag=document.getElementById('qvTag'), qvMedia=document.getElementById('qvMedia');
    let nearest=null;
    function updateCardsAndHint(){
      const W=innerWidth,H=innerHeight; let best=null,dmin=Infinity;
      for(const {el,obj,pill} of cardsRef){
        tmpV.copy(obj.position); tmpV.y+=10; tmpV.project(camera);
        const on=tmpV.z<1&&tmpV.z>-1; let x=(tmpV.x*.5+.5)*W,y=(-tmpV.y*.5+.5)*H;
        if(on){ x=clamp(x,18,W-18); y=clamp(y,80,H-96); el.style.left=x+'px'; el.style.top=y+'px';
          const dist=camera.position.distanceTo(obj.position); const a=THREE.MathUtils.clamp(1-(dist-60)/220,0,1);
          el.style.opacity=a; el.style.transform=`translate(-50%,-100%) scale(${0.92+a*0.1})`;
        } else { el.style.opacity=0; }
        const d=ship.position.distanceTo(obj.position); if(d<dmin){dmin=d; best=obj;}
        if(pill) pill.style.opacity=0;
      }
      const TH=28; nearest=(best&&dmin<TH)?best:null;
      if(nearest && controlsEnabled && !qv.classList.contains('show')){
        const ref=cardsRef.find(c=>c.obj===nearest); if(ref&&ref.pill){ ref.pill.style.opacity=1; }
      }
    }
    function qvOpenFor(pl){
      controlsEnabled=false;
      const p=pl.userData.project;
      qvTitle.textContent=p.title; qvTag.textContent=p.tag||'';
      qvMedia.style.backgroundImage=`url('${p.cover||''}')`;
      qv.style.display='flex'; qv.classList.add('show'); qv.setAttribute('aria-hidden','false');
    }
    function qvCloseFn(){ qv.classList.remove('show'); qv.style.display='none'; qv.setAttribute('aria-hidden','true'); controlsEnabled=true; }
    document.getElementById('qvExit').addEventListener('click',qvCloseFn);
    addEventListener('keydown',e=>{
      if(e.code==='KeyQ' && qv.classList.contains('show')){ qvCloseFn(); return; }
      if(e.code==='KeyE'){
        if(qv.classList.contains('show')){ window.location.href='projects.html'; }
        else if(controlsEnabled && nearest){ qvOpenFor(nearest); }
      }
    });

    /* Planet spin */
    function spinPlanets(dt){ for(const pl of planets){ pl.rotation.y += (pl.userData.spin||0.03)*dt; } }

    /* ---- AI Ships ---- */
    const AI_COUNT = 12;
    const aiShips = [];
    const aiTmp = new THREE.Vector3();
    const aiForward = new THREE.Vector3(1,0,0);
    function createAIShip(pos=new THREE.Vector3()){
      const group=new THREE.Group();
      // model (clone varsa), yoksa küçük kapsül
      let model=null, exhaust = new THREE.Vector3(-1.2,0,0);
      if(baseModel){
        model = cloneSkeleton(baseModel);
        const info = fitModelToShip(model);
        exhaust.copy(info.exhaustLocal.clone().multiplyScalar(0.6)); // biraz kısa duman
      }else{
        model = new THREE.Mesh(new THREE.CapsuleGeometry(.4,1.4,6,12), new THREE.MeshStandardMaterial({color:0x93a3ff,metalness:.2,roughness:.6,emissive:0x0f1633,emissiveIntensity:.25}));
        model.rotation.z=Math.PI/2;
      }
      // invert renk efekti
      model.traverse(n=>{ if(n.isMesh){ n.material = n.material.clone(); n.material.color.offsetHSL(0.5,0,0); }});
      group.add(model);
      group.position.copy(pos);
      group.rotation.y = Math.random()*Math.PI*2;

      // part. havuzu
      const fPool=[...Array(50)].map(()=>makeSprite(flameMat)), sPool=[...Array(36)].map(()=>makeSprite(smokeMat));
      const fData=fPool.map(()=>({life:0,max:0,vel:new THREE.Vector3()})), sData=sPool.map(()=>({life:0,max:0,vel:new THREE.Vector3()}));
      const exhaustFn = (out)=>worldFromExhaust(out, group, exhaust);

      function aiSpawnFlame(n,intensity=1){
        for(let i=0;i<fPool.length&&n>0;i++){
          if(fData[i].life>0)continue; n--;
          const sp=fPool[i],d=fData[i]; const pos=new THREE.Vector3(); exhaustFn(pos);
          sp.position.copy(pos); sp.scale.setScalar(0.8+Math.random()*1.2*intensity);
          d.max=.32+Math.random()*.22; d.life=d.max;
          const dir=new THREE.Vector3(-1,THREE.MathUtils.randFloatSpread(.32),THREE.MathUtils.randFloatSpread(.32)).applyQuaternion(group.quaternion);
          d.vel.copy(dir.multiplyScalar(11+16*intensity)); sp.material.opacity=.9; sp.visible=true;
        }
      }
      function aiSpawnSmoke(n,boost=1){
        for(let i=0;i<sPool.length&&n>0;i++){
          if(sData[i].life>0)continue; n--;
          const sp=sPool[i],d=sData[i]; const pos=new THREE.Vector3(); exhaustFn(pos);
          sp.position.copy(pos); const s=1.0+Math.random()*2.0*boost; sp.scale.set(s,s,1);
          d.max=.9+Math.random()*.7; d.life=d.max;
          const dir=new THREE.Vector3(-1,THREE.MathUtils.randFloatSpread(.22),THREE.MathUtils.randFloatSpread(.22)).applyQuaternion(group.quaternion);
          d.vel.copy(dir.multiplyScalar(2.8+1.8*boost)); sp.material.opacity=.3; sp.visible=true;
        }
      }
      function aiUpdateParticles(dt){
        for(let i=0;i<fPool.length;i++){
          const p=fPool[i],d=fData[i]; if(d.life<=0){p.visible=false;continue;}
          d.life-=dt; p.position.addScaledVector(d.vel,dt); const t=d.life/d.max; p.material.opacity=.15+.75*t; const s=(.6+1.6*(1-t)); p.scale.set(s,s,1); if(d.life<=0)p.visible=false;
        }
        for(let i=0;i<sPool.length;i++){
          const p=sPool[i],d=sData[i]; if(d.life<=0){p.visible=false;continue;}
          d.life-=dt; p.position.addScaledVector(d.vel,dt); p.position.y+=dt*.5; const t=d.life/d.max; p.material.opacity=.28*t; const s=p.scale.x*(1+.3*dt); p.scale.set(s,s,1); if(d.life<=0)p.visible=false;
        }
      }

      const ai={
        group, vel:0, yaw:group.rotation.y, pitch:0, throttle:0, state:'roam',
        timer: 1+Math.random()*2, target: null, wander: new THREE.Vector2(Math.random()*1000,Math.random()*1000),
        updateParticles: aiUpdateParticles, spawnFlame: aiSpawnFlame, spawnSmoke: aiSpawnSmoke
      };
      aiShips.push(ai); scene.add(group);
      return ai;
    }

    function pickPlanet(){
      return planets[Math.floor(Math.random()*planets.length)];
    }

    function steerToward(ai, targetPos, dt){
      // hedef yön
      const fwd=aiForward.clone().applyQuaternion(ai.group.quaternion);
      const to=targetPos.clone().sub(ai.group.position);
      const yawTarget=Math.atan2(to.z, to.x);
      const yawCur=ai.yaw;
      const dy=angleDiff(yawTarget, yawCur);
      ai.yaw += THREE.MathUtils.clamp(dy, -1.6*dt, 1.6*dt);

      // hafif pitch sapması (yukarı-aşağı)
      const aimY = clamp(to.y/30,-0.6,0.6);
      ai.pitch = lerp(ai.pitch, aimY, 1-Math.pow(0.2,dt*60));
    }

    function updateAI(dt){
      for(const ai of aiShips){
        ai.timer -= dt;
        if(!ai.target || ai.timer<=0){
          // yeni hedef belirle
          if(Math.random()<0.6){ ai.target = pickPlanet(); ai.state='approach'; ai.timer= 6+Math.random()*8; }
          else { ai.target = null; ai.state='roam'; ai.timer= 4+Math.random()*6; }
        }

        // durumlara göre hız hedefi
        let speedT = 10;
        if(ai.state==='approach') speedT = 16;
        if(ai.state==='roam')     speedT = 10;
        if(ai.state==='loiter')   speedT = 0;

        // zaman zaman fren
        if(Math.random()<0.003){ speedT = 0; ai.state='loiter'; ai.timer = 0.8+Math.random()*1.6; ai.spawnSmoke(10,1.2); }

        // hedefe göre direksiyon
        if(ai.state==='approach' && ai.target){
          const tp = ai.target.position.clone();
          const r  = ai.target.userData.radius || 10;
          // biraz "yanından" geçmek için ofset
          tp.y += Math.sin((performance.now()+ai.wander.x)*0.001)*2.0;
          steerToward(ai, tp, dt);
          // yakınsa biraz bekleyip ayrıl
          const d = ai.group.position.distanceTo(ai.target.position);
          if(d < r + 6){ ai.state='loiter'; ai.timer=1.2+Math.random()*1.4; speedT=0; }
        } else if(ai.state==='roam'){
          // perlin yok → basit wander gürültüsü
          ai.wander.x += dt; ai.wander.y += dt*1.13;
          const angle = Math.sin(ai.wander.x*0.7)*0.6 + Math.cos(ai.wander.y*0.6)*0.6;
          ai.yaw += angle*dt*0.6;
          ai.pitch = lerp(ai.pitch, Math.sin(ai.wander.x*0.9)*0.2, 1-Math.pow(0.3,dt*60));
        }

        // throttle/hız
        const acc = 18;
        const drag = (speedT<=0.1)? 0.92 : 0.97;
        const tTarget = (speedT>0)? 1:0;
        ai.throttle += (tTarget-ai.throttle)*(1-Math.pow(.25,dt*60));
        ai.vel += ai.throttle*acc*dt;
        ai.vel *= Math.pow(drag, dt*60);
        ai.vel = clamp(ai.vel, -18, 20);

        // dönüşleri uygula
        ai.group.rotation.set(ai.pitch, ai.yaw, THREE.MathUtils.damp(ai.group.rotation.z, -ai.yaw*0.08, 8, dt));

        // hareket
        const fwdNow = aiForward.clone().applyQuaternion(ai.group.quaternion);
        ai.group.position.addScaledVector(fwdNow, ai.vel*dt);

        // partikül
        if(ai.throttle>0.02){ ai.spawnFlame(3+Math.floor(ai.throttle*6), 0.8+ai.throttle*0.6); }
        if(ai.throttle<0.02 && ai.vel>2){ ai.spawnSmoke(2,1.0); }

        // sahne sınırı – geri çevir
        const L=220; if(ai.group.position.length()>L){
          const toCenter = new THREE.Vector3().sub(ai.group.position).setY(0);
          steerToward(ai, ai.group.position.clone().add(toCenter), dt);
          ai.throttle=1;
        }

        // gezegen çarpışması (itme)
        for(const pl of planets){
          const pr = pl.userData.radius;
          const min = pr + 2.5; // AI gemi yarıçap ~2.5
          const d = ai.group.position.distanceTo(pl.position);
          if(d<min){
            // içeri girdiyse dışarı it, hız düşür
            const n = ai.group.position.clone().sub(pl.position).normalize();
            ai.group.position.copy(pl.position).addScaledVector(n, min+0.1);
            ai.vel *= 0.5;
            ai.yaw += (Math.random()-0.5)*0.6; // sekme
          }
        }
        ai.updateParticles(dt);
      }

      // AI ↔ AI çarpışma (basit ayırma)
      for(let i=0;i<aiShips.length;i++){
        for(let j=i+1;j<aiShips.length;j++){
          const A=aiShips[i], B=aiShips[j];
          const d=A.group.position.distanceTo(B.group.position);
          const min=4.2;
          if(d<min && d>0.0001){
            const n = B.group.position.clone().sub(A.group.position).divideScalar(d);
            const push = (min-d)*0.5;
            A.group.position.addScaledVector(n, -push);
            B.group.position.addScaledVector(n,  push);
            A.vel*=0.9; B.vel*=0.9;
          }
        }
      }
    }

    function spawnAIShips(){
      for(let i=0;i<AI_COUNT;i++){
        const pos = new THREE.Vector3(
          THREE.MathUtils.randFloatSpread(80),
          THREE.MathUtils.randFloatSpread(22),
          THREE.MathUtils.randFloatSpread(80)
        );
        createAIShip(pos);
      }
    }

    /* Player ↔ gezegen/AI çarpışmaları */
    function collisionsPlayer(dt){
      // gezegen
      for(const pl of planets){
        const pr = pl.userData.radius;
        const min = pr + SHIP_RADIUS;
        const d = ship.position.distanceTo(pl.position);
        if(d<min){
          const n = ship.position.clone().sub(pl.position).normalize();
          ship.position.copy(pl.position).addScaledVector(n, min+0.05);
          velF *= 0.6; // hız kes
          // bounce yönü için biraz yaw ekle
          yaw += (Math.random()-0.5)*0.3;
        }
      }
      // AI
      for(const ai of aiShips){
        const d = ship.position.distanceTo(ai.group.position);
        const min = 2.5 + SHIP_RADIUS;
        if(d<min && d>0.0001){
          const n = ship.position.clone().sub(ai.group.position).divideScalar(d);
          const push = (min-d);
          ship.position.addScaledVector(n,  push*0.6);
          ai.group.position.addScaledVector(n,-push*0.4);
          velF*=0.85; ai.vel*=0.85;
        }
      }
    }

    /* Satellites & debris (küçük dekor) */
    const satellites=[], debrisPool=[];
    function makeSatellite(x,y,z){
      const group=new THREE.Group();
      const body=new THREE.Mesh(new THREE.BoxGeometry(1.0,0.8,0.6), new THREE.MeshStandardMaterial({color:0xd0d6e5,metalness:.4,roughness:.6}));
      const panelMat=new THREE.MeshStandardMaterial({color:0x6aa7ff,emissive:0x0e1a44,emissiveIntensity:.4,roughness:.4});
      const panelL=new THREE.Mesh(new THREE.BoxGeometry(2.0,0.1,1.0), panelMat);
      const panelR=panelL.clone(); panelL.position.set(-1.5,0,0); panelR.position.set(1.5,0,0);
      const antenna=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,2.0,8), new THREE.MeshStandardMaterial({color:0xaaaaaa,metalness:.5,roughness:.5}));
      antenna.position.set(0,0.8,0); antenna.rotation.x=Math.PI/2;
      group.add(body,panelL,panelR,antenna);
      group.position.set(x,y,z);
      group.scale.setScalar(3);
      group.userData.spin = THREE.MathUtils.randFloat(0.3,0.8);
      scene.add(group);
      satellites.push(group);
    }
    for(let i=0;i<5;i++){
      const a=Math.random()*Math.PI*2, r=THREE.MathUtils.randFloat(50,120);
      makeSatellite(Math.cos(a)*r, THREE.MathUtils.randFloatSpread(12), Math.sin(a)*r);
    }
    function spawnDebris(at){
      for(let i=0;i<12;i++){
        const cube=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.12,0.12), new THREE.MeshStandardMaterial({color:0x9fb4ff,metalness:.3,roughness:.4,transparent:true,opacity:1}));
        cube.position.copy(at);
        const vel=new THREE.Vector3(THREE.MathUtils.randFloatSpread(6), THREE.MathUtils.randFloatSpread(4)+1.2, THREE.MathUtils.randFloatSpread(6));
        const life=1.6+Math.random()*0.9;
        debrisPool.push({mesh:cube, vel, life, max:life});
        scene.add(cube);
      }
    }
    function updateSatellites(dt){
      for(const s of satellites){ s.rotation.y += s.userData.spin*dt; }
      for(let i=satellites.length-1;i>=0;i--){
        const s=satellites[i];
        if(ship.position.distanceTo(s.position) < 3.0){
          spawnDebris(s.position); scene.remove(s); satellites.splice(i,1);
        }
      }
      for(let i=debrisPool.length-1;i>=0;i--){
        const d=debrisPool[i]; d.life-=dt;
        d.mesh.position.addScaledVector(d.vel,dt); d.vel.multiplyScalar(0.985); d.mesh.rotation.x+=dt*2; d.mesh.rotation.y+=dt*2.4;
        const t=Math.max(0,d.life/d.max); d.mesh.material.opacity = t;
        if(d.life<=0){ scene.remove(d.mesh); debrisPool.splice(i,1); }
      }
    }

    /* Start */
    const startEl=document.getElementById('start');
    document.getElementById('btnStart').addEventListener('click',()=>{
      startEl.classList.add('hide');
      setTimeout(()=>{ controlsEnabled=true; },550);
    });

    /* Resize & loop */
    addEventListener('resize',()=>{renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();});
    const clock=new THREE.Clock();
    function loop(){
      const dt=Math.min(.033,clock.getDelta());
      updateShip(dt);
      updateCamera(dt);
      collisionsPlayer(dt);
      spinPlanets(dt*0.5);
      updateAI(dt);
      updateSatellites(dt);
      updateCardsAndHint();
      renderer.render(scene,camera); requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
